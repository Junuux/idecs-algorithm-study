##boj 10989: 수 정렬하기 3
>주소: https://www.acmicpc.net/problem/10989

### 문제 해결 방향
이 문제는 메모리제한과 시간 제한이 존재한다. 
따라서 입력 받는데로 list를 append 하고 sort 함수를 사용하면 메모리제한이 걸린다.
입력을 받고, in-sorting해서 리스트를 출력하면 시간제한이 걸린다.

---> 입출력값의 범위가 1 ~ 10000이므로, 크기가 10001인 배열을 미리 선언해서, 
입력한 값에 해당하는 index 의 값을 +1 해나가야한다.
###### 카운팅 정렬 사용 : '특별한 조건'이 성립해야지 사용할 수 있는 정렬 , 특별한 조건은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을때를 말한다.

#####1. 입출력값 범위가 크기때문에 시간 초과 방지 위해 sys 모듈을 import 한다.

        import sys
        N = int(sys.stdin.readline())
stdin.readline(), stdout.write() 를 사용해서 시간 초과를 방지해야한다.

#####2. 크기가 10001인 list를 미리 선언한다.
        
        lst = [0] * 10001
for문을 사용하지 않고 리스트를 선언해야 시간 초과를 방지할 수 있다.
append 함수를 사용할 시 시간초과가 발생한다.

#####3. 해당 list의 index 값을 입력 받아 index에 해당하는 값을 +1 해주고, index 값을 list[index] 만큼 반복해서 출력한다.

    for _ in range(N):
    lst[int(sys.stdin.readline())] += 1

    for i in range(1,10001):
        for _ in range(lst[i]):
            sys.stdout.write(str(i)+'\n')

갯수 정해져 있으므로 counting 정렬 사용


### 시간 복잡도 : O(N+K)
카운팅 정렬의 시간 복잡도는 O(N+K) 이다.
여기서 K는 정렬한 수 중 가장 큰 값을 말한다. 
ex) N = 10, K = 100 이면 O(N^2)
즉, 만약 K가 N 보다 작은 수이면 O(N)이 되지만, K가 N보다 매우 큰 수이면
O(무한)이 될 수 있다.
따라서 정렬할 수들의 최대값에 영향을 받는 알고리즘이다.

카운팅 정렬은 크기 비교를 하지 않고, 순서가 섞이지 않는다. 따라서
적은 개수의 숫자를 정렬할 때 계수 정렬을 사용하는 것이 좋다.
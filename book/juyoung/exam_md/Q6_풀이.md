# <span style = "color:red">Q6: 무지의 먹방 라이브
> 기출: 2019 카카오 신입 공채
> 문제 주소: https://programmers.co.kr/learn/courses/30/lessons/42891

### 문제 설명
- 회전판에 N개의 음식 존재, 각 음식은 1~ N의 번호 가진다.
- 각 음식 섭취하는데 일정 시간이 소요된다.
- 음식을 1초 동안 섭취한 후, 다음 음식을 섭취한다.
- K 초 후에 먹어야하는 음식의 번호 구하기

### 문제 해결 방향
#### 풀이
- 우선 순위 큐를 사용하여, 섭취하는데 시간이 적게 걸리는 음식 순으로 정렬한다.
- 총 걸린 섭취 시간 + (현재 음식을 다 섭취하는데 걸리는 시간 - 이전 음식들을 섭취하는데 걸리는 시간) * 남은 음식의 개수 <= K 때 까지 반복한다.
- __가장 시간이 적은 음식을 기준으로 계산하면, 시간이 더 걸리는 음식도 자연스럽게 계산할 수 있다.__

### 소스코드
1. 전체 음식을 다 먹는 시간보다, k가 크거나 같으면 k 초 전에 모든 음식을 다 먹을 수 있으므로 -1 return
```python
 # 전체 음식을 먹는 시간보다 k가 크거나 같다면 -1
    if sum(food_times) <= k:
        return -1
```
2. 음식을 다 섭취하는데 걸리는 시간이 작은 순으로 처리하기 위해 우선 순위 큐에 `(섭취시간, 음식번호)` 를 저장한다.
```python 
    # 시간이 적은 순 정렬
    q = []
    for i in range(len(food_times)):
        heapq.heappush(q ,(food_times[i] , i +1))
```
3. 이전에 먹기 위해 사용한 시간 , 직전에 다 먹은 음식 시간, 총 음식의 개수를 저장하는 변수 생성
```python

    sum_value = 0  # 먹기 위해 사용한 시간
    previous = 0 # 직전에 다 먹은 음식 시간
    length = len(food_times)
```
4. 반복문
- key point : 가장 시간이 적은 음식을 기준으로 계산하면, 시간이 더 걸리는 음식도 자연스럽게 계산할 수 있다.
- sum_value + (현재 음식의 시간 - 이전 음식 시간) * 현재 음식 개수와 k 비교 
- (현재 음식 섭취 시간 - 이전 음식 시간) = 이전에 섭취한 시간 빼고, 지금 남은 음식의 양
- * length = 지금 남은 음식을 다 먹을려면 length 만큼 돌면서 차례차례 먹어야 하므로
- 현재 까지 남은 가장 작은 음식을 먹는 데 까지 걸린 시간이 K 보다 크면, 그 음식을 다 먹지 못하고, 남은 것 중 하나 차례에 중단되는 것 
- __이전 음식 시간 빼는 이유 -> 이전 음식 시간 계산할 때, 같이 시간이 -1 됐을 것 이므로__
```python
while sum_value +(q[0][0] - previous) * length <= k:
    now = heapq.heappop(q)[0]
    sum_value += (now-previous) * length 
    length -= 1 # 다 먹은 음식 제외
    previous = now # 이전 음식 시간 재설정

```
5. 반복문을 나왔다면, 남은 음식을 차례차례 순환해서, (k-이전 음식들 다 먹는데 걸린 시간) 번째 음식을 먹으면 된다.
- 남은 음식 번호 오름차순으로 정렬한다.
- 해당 음시 중 음식 선택
```python
 # 남은 음식 중 (k - 이전 음식 다 먹은 시간 ) 번째 음식 고르기
    result = sorted(q,key=lambda x:x[1])
    return result[(k-sum_value) % length][1]
```
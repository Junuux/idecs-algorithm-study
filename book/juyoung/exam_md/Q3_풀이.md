# Q3: 문자열 뒤집기
> 문제 주소: https://www.acmicpc.net/problem/1439
> silver 5


### 문제 설명
- 0과 1로만 이루어진 문자열 존재
- 연속되는 하나 이상의 숫자를 잡고 모두 뒤집기 가능
- 최소로 뒤집어서 모두 같은 숫자가 되도록 만든다

### 문제 해결 방향
#### 내 생각
- 연속되는 0의 그룹의 수 VS 연속되는 1의 그룹의 수 count 해서, 더 작은 그룹 수 == 행동의 횟수
- 이전 수를 저장해서, 이전 수랑 같은 경우 pass 하고, 이전 수랑 다른 경우 이전 수에 해당하는 그룹의 count를 +1 한다.
- 마지막 수에 대해서 처리하기 위해, for 문 밖에서 한번 더 조건을 확인한다.
#### 풀이
- 현재 수와 다음 수가 달라지는 경우 , 다음 수에서 1로 바뀌는 경우 그룹 1를 count 해준다
- 처음 수를 처리하기 위해서, 0 index의 수에 해당하는 그룹의 수를 +1 해준다.
#### 다른 점
- 이전 수를 비교한다는 점, 다음 수를 비교한다는 점이 다르다.
- 따라서 이전 수를 비교할 경우 마지막 경우에 대해서 따로 처리해줘야하고, 다음 수를 비교하는 경우 처음 경우에 대해 따로 처리해줘야 한다.
### 소스 코드
1. data를 입력 받아 string으로 저장한다.
- 그룹 1 , 그룹 0의 수를 세기 위해 변수 형성
```python
data = input()

# O로 이루어진 그룹의 수 count
zero = 0
# 1로 이루어진 그룹의 수 count
one = 0
```
2. index 0에 해당하는 그룹의 수 + 1
```python
# 처음 수 부터, 그룹 수 count
if data[0] == '0':
    zero +=1
elif data[0] == '1':
    one += 1
```
3. index 1 ~ len-1 까지 현재 수랑 다음 수를 비교하며, 바뀌는 경우 바뀐 문자의 그룹의 수 +1
```python
for i in range(len(data) -1):
    if data[i] != data[i+1]:
        if data[i+1] == '0':
            zero += 1
        elif data[i+1] == '1':
            one += 1

```
4. 두 그룹 중 더 작은 수 결과로 출력
```python
# 두 그룹 중 작은 그룹 수
print(min(zero,one))

```
## DFS/BFS - 대표적인 탐색 알고리즘

- 탐색: 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
- 자료구조: 데이터를 표현하고 , 관리하고, 처리하기 위한 구조

---

  ### 스택, 큐
  핵심적인 두가지 함수로 구성된다.
  
  - 삽입(push) : 데이터를 삽입한다.
  - 삭제(pop): 데이터를 삭제한다.
  ###  스택 : 선입후출, LILO
  (입출구) : 입구와 출구가 하나로 같이 이용된다.
  파이썬에서 스택을 사용할 때 별도의 라이브러리를 사용할 필요 없다.
  기본 리스트에서 
  - append() : 리스트의 가장 뒤쪽에 데이터 삽입
  - pop(): 리스트의 가장 뒤쪽에서 데이터 꺼낸다.
  ### 큐 : 선입선출, FIFO
  (입구 ---- 출구) : 입구와 출구가 하나씩 정해져 있다.
  - 파이썬으로 큐 구현할 때 collections 모듈에서 제공하는 deque 자료구조 활용
  ####deque는 스택과 큐의 장점을 모두 채택한 것
  - 데이터 넣고 빼는 속도가 리스트 자료형에 비해 효율적이며 간단하다.
  - collections 모듈은 기본라이브러리 이므로 사용이 가능하다.
  - list(deque) 를 사용하면 deque 객체를 리스트 자료형으로 변경 가능하다.
  ```python
from collections import deque
      
# 큐(Queue 구현을 위해 deque 라이브러리를 이용한다.
queue = deque()
queue.append(5) # queue에 값을 넣는다.
queue.popleft() # 가장 먼저 들어온 값이 나간다.
  ```

---
  ### 재귀함수: 자기 자신을 다시 호출하는 함수
  - 프랙털 구조와 흡사하다.
  #### 재귀함수가 언제끝나는지 종료 조건을 반드시 명시해야 한다.
  - 컴퓨터 내부에서 재귀 함수의 수행은 스택 자료구조를 이용한다.
    - 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료된다.
    ```python
     # n! 를 재귀적으로 구현해보기
    def factorial_recursive(n):
       if n <= 1: return 1
       return n * factorial_recursive(n-1)
    
    ```
    - 재귀적으로 구현했을 때 장점 : 
    점화식을 그대로 소스 코드로 옮겼기 때문에 더 간단하다.
        - 점화식: 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것
    
---
## 탐색 알고리즘 DFS/BFS
- 그래프 탐색 : 하나의 노드를 시작으로 다수의 노드를 방문하는 것
- '두 노드가 인접하다' = 두 노드가 간선으로 연결되어 있다.
#### 그래프를 표현하는 2가지 방법
- 인접행렬: 2차원 배열로 그래프의 연결 관계를 표현한다.
- 인접 리스트: 리스트로 그래프의 연결관계를 표현한다.

##### 인접행렬 (2차원 리스트로 구현)
- 인접하지 않은 노드들끼리는 `무한의 비용` 이라고 작성한다.
```python
INF = 99999999999 # 무한의 비용 선언

# 2차원 리스트를 이용해 인접행렬 표현
graph = [
    [0,7,5],
    [7,0,INF],
    [5,INF,0]
]
```
##### 인접 리스트 (2차원 리스트로 구현)
```python
#행(Row)이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

# 노드 0 에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1,7))

# 노드 1에 연결된 노드의 정보 저장(노드, 거리)
graph[1].append(((0,7)))
```
#### 인접 행렬 VS 인접 리스트
|항목|인접 행렬|인접 리스트|
|---|---|---|
|메모리 측면|모든 관계 저장-> 노드 수 많아지면 낭비|연결된 정보만을 저장-> 효율적|
|연결 정보 얻기|빠르다|느리다(데이터 하나씩 확인)|

### DFS : 깊이 우선 탐색 -> 스택 자료구조를 이용한다.
> 멀리있는 노드를 우선으로 탐색한다.
> 
> 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후 , 다시 돌아가 다른 경로를 탐색
- 동작 과정
    1. 탐색 시작 노드를 스택에 삽입하고 방문 처리한다.
    2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다.
        방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
    3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
##### 시간 복잡도 : O(N) : 데이터 갯수 N개 일 때

```python
# Graph 메서드 정의
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end = ' ')
    # 현재 노드와 연결된 다른 노드를 재귀적 방문
    # 인접 리스트로 구현
    for i in graph[v]:
        if not visited[i]:
            dfs(graph,i,visited)
            
```
### BFS : 너비 우선 탐색 -> 큐 자료구조를 이용한다. (deque 라이브러리 이용)
> 가까운 노드부터 탐색한다.
- 동작 과정
    1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
    2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
    3. 2번 과정을 더 이상 방문할 수 없을 때 까지 반복한다.
##### 시간 복잡도 : O(N) : 데이터 갯수 N개 일 때   
#### DFS 보다 BFS의 수행 시간이 더 좋다.
```python
from collections import deque

# BFS 메서드 정의
def bfs(graph, start, visited):
    # 큐 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    # 현재 노드를 방문 처리
    visited[v] = True
    # 큐가 empty가 될 때 까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아서 출력
        v = queue.popleft()
        print(v, end = ' ')
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 찾아서 방문 처리 후 큐에 삽입
        # 인접 리스트로 구현
        for i in graph[v]:
            if not visited[i]:
                visited[i] = True
                queue.append(i)
    
```
### DFS BFS 정리 표
|   |DFS|BFS
|---|---|---
|동작 원리| stack | queue
|구현 방법| 재귀 함수 이용| 큐 자료구조 이용

##### ---> 2차원 배열에서의 탐색 문제를 만나면 그래프 형태로 바꿔서 생각하면 풀이 방법을 조금 더 쉽게 떠올릴 수 있다. 따라서 탐색 문제를 보면 그래프 형태로 표현한 다음 풀이법을 고민하자.
---
활용
1. dfs 는 덩어리를 구할 때 쓸 수 있다.
2. bfs 는 최단 경로를 구할 때 쓸 수 있다.
   이때, 각 queue 에 들어갈 때 마다의 level를 표시한다.
   이 level은 각 node 마다의 최단 경로를 의미한다.
   ```python
    def bfs(graph, N, M):
    # dequeue 에 튜플을 넣는다.
    q = deque()
    q.append((0,0))
    # queue 가 빌 때 까지
    while len(q) != 0:
        r,c = q.popleft()
        # 상하좌우 인접한 방문하지 않은 노드 존재하는지 확인
        for i in range(4):
            nr = r + dr[i]
            nc = c + dc[i]
            if 0 <= nr < N and 0 <= nc < M:
                if graph[nr][nc] == 1:
                    # 해당 노드 까지의 최단 경로를 더해준다.
                    # 한 노드에 대한 인접 노드 들은 같은 최단 경로를 같게 된다.
                    # level은 최단 경로를 나타낸다.
                    graph[nr][nc] = graph[r][c] + 1
                    q.append((nr, nc))
   ```
# <span style = "color:red">Q5: 볼링공 고르기

### 문제 설명
- 각각의 무게를 가지는 N개의 볼링공 주어진다.
- 공의 번호 1 ~ N 까지 주어진다.
- 두 사람이 서로 무게가 다른 볼링공을 고른다.
- 두 사람이 고를 수 있는 볼링공 번호의 조합의 최대 경우의 수를 구한다.

### 문제 해결 방향
#### 내 생각
- N + 1크기의 배열 생성한다.
- 해당 배열 보다 큰 번호 이면서, 무게가 같지 않으면 count +1
- 비효율 : O(n^2) 시간 -> 너무 오래 걸린다.

#### 풀이 
- 각 무게별로 가지는 공의 갯수 저장한다.
- `A가 무게를 선택했을 때, B가 공을 고를 수 있는 공의 갯수 * 해당 무게 공의 수` 를 다 더하면 총 경우의 수가 된다.
- B가 고를 수 있는 공의 갯수는 이전 무게에서 선택했던 경우를 제외해야한다.

### 소스 코드
1. 볼링공의 개수 n, 공의 최대 무게 M을 입력받고, 공의 무게를 입력 받는다.
```python
n,m = map(int,input().split())
balls = list(map(int,input().split()))
```
2. 무게별 공의 수 센다.
- 공의 무게는 최대 10 이므로 11 크기의 배열을 생성한다.
```
array = [0] * 11 # 공의 무게는 1~ 10 까지
for ball in balls:
    array[ball] += 1
```
3. 무게 1 ~ m 까지 반복문을 돌린다.
- 공의 갯수 n 은 B가 선택하는 경우의 수 이다.
- n에서 A가 선택할 수 있는 개수를 제외 한다. 
```python
count = 0
for i in range(1,m+1):
    n -= array[i] # A가 선택할 수 있는 개수 = 무게 i 인 볼링공의 개수
    count += array[i] * n # B가 선택하는 경우의 수와 곱하기

print(count)
```

### 시간 복잡도 - O(m)
- 공의 최대 무게 만큼 반복하므로
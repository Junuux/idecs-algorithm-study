# 다이나믹 프로그래밍
> 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘
> 큰 문제를 작게 나구고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법

## 중복되는 연산을 줄이자
- 메모리 공간을 약간 더 사용해, 연산 속도를 비약적으로 증가시킬 수 있는 방법 = 동적 계획법 -> 다이나믹 프로그래밍 기법

### ex) 피보나치 수열
> 이전 두 항의 합을 현재항으로 설정하는 특징이 있는 수열
- 점화식 : `a(n) = a(n-1) + a(n-2), 단 a(1) = 1, a(2) = 1`
- 수열을 파이썬에서는 '연속된 많은 데이터'를 처리할 수 있는 __리스트 자료형__ 으로 처리
    - c/c++에서는 배열을 이용해 처리
    - 리스트, 배열 모두 '연속된 많은 데이터'를 처리하는 점 동일
    - 파이썬의 경우 기본 리스트 자료형이 연결 리스트의 기능을 포함하고 있는 점이 다른 언어의 배열과 차이점이다.

- 재귀 함수를 통해 피보나치 수열의 수학적 점화식 표현
  ```python
  def fibo(n):
      if n == 1 or n == 2:
            return 1
      else:
            return  fibo(n-1) + fibo(n-2)
  
  print(fibo(4))
  ```

#### -재귀적으로 피보나치 수열의 표현시 문제점 -> n이 커질수록 수행 시간이 기하급수적으로 늘어난다. : O(2^N)
- 동일한 함수가 반복적으로 호출된다. __이미 한 번 계산했지만, 계속 호출할 때마다 계산하는 것__
- __f(n)에서 n이 커지면 커질수록 반복해서 호출하는 수가 많아진다.__

## 다이나믹 프로그래밍의 조건
#### 1. 큰 문제를 작은 문제로 나눌 수 있다.
#### 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

## 메모이제이션 기법: Memoization
- 다이나믹 프로그래밍을 구현하는 방법 중 한 종류
- 한 번 구한 결과를 메모리 공간에 메모해두고, 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
- 메모이제이션은 값을 저장하는 방법이므로 `캐싱(caching)` 이라고도 한다.
- 구현 방법: __한 번 구한 정보를 리스트에 저장한다__ -> 다이나믹 프로그래밍을 재귀적으로 수행하다가 
  같은 정보가 필요할 때는 이미 구한 정답을 그대로 리스트에서 가져온다. 
  
  __< top-down 방식으로 푼 피보나치 수열> : O(N)__
  ```python
  # 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
  d = [0] * 100
  # 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
  def fibo(x):
        # 종료 조건(1 혹은 2일 때 1을 반환)
        if x == 1 or x == 2:
            return 1
        # 이미 계산한 적 있는 문제라면 그대로 반환
        if d[x] != 0:
            return d[x]
        # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
        d[x] = fibo(x-1) + fibo(x-2)
        return d[x]
  
  print(fibo(99))
  ``` 
 
 
###다이나믹 프로그래밍 VS 퀵 정렬(분할 정복 알고리즘)
1. 다이나믹 프로그래밍
  - 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법
  - 문제들이 서로 영향을 미치고 있다.
  - __한 번 해결했던 문제를 다시금 해결한다.__
  - 이미 해결된 부분 문제에 대한 답을 저장해 놓고, 이미 해결된 문제니 다시 해결할 필요없이 반환하는 것
  - 재귀 함수 대신에 반복문을 사용하여 오버헤드를 줄일 수 있다. ->(일반적으로 반복문을 이용한 다이나믹 프로그래밍이 더 성능이 좋다.)
2. 퀵 정렬 -> 분할 정복 알고리즘
  - 정렬할 리스트를 분할하며 전체적으로 정렬될 수 있도록 한다.
  - 한번 기준 원소(pivot)가 자리를 변경해서 자리를 잡게 되면 그 기준 원소의 위치를 더 이상 바뀌지 않고, 그 피벗값을 다시 처리하는
    부분은 존재하지 않는다.
    

##탑 다운 방식(재귀)과 보텀업 방식(반복문)
1. 탑 다운 방식: 재귀 함수 이용
  - 큰 문제를 해결하기 위해 작은 문제를 호출한다.
2. 보텀업 방식: 단순히 반복문을 이용
  - 작은 문제부터 차근차근 답을 도출한다.

  __< bottom-up 방식으로 푼 피보나치 수열> : O(N)__
  ```python
  # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
  d = [0] * 100
  
  # 첫번째 피보나치 수와 두 번째 피보나치 수는 1
  d[1] = 1
  d[2] = 1
  n = 99
  
  # 피보나치 함수 반복문으로 구햔(보텀업 다이나믹 프로그래밍)
  for i in range(3,n+1):
      d[i] = d[i-1] + d[i-2]
  
  print(d[n])
  ```
- __전형적인 다이나믹 프로그래밍의 형태는 보텀업 방식__
- 보텀업 방식에서 사용되는 결과 저장용 리스트: `DP 테이블` 이라고 부른다.
- 메모이제이션은 탑 다운 방식에 국한되어 사용되는 표현 -> 이전에 계산된 결과를 일시적으로 기록(넓은 개념)
- 메모이제이션은 때에 따라서 사전 자료형같은 다른 자료형 이용 가능
  - 연속적이지 않은 경우 사전 자료형 유용
  
### 다이나믹 프로그래밍 유형임을 파악하는 법
- 완전 탐색 알고리즘으로 접근 했을 때 시간이 매우 오래 걸릴 경우 
  -> 다이나믹 프로그래밍 적용할 수 있는 지 해결하고자 하는 __부분 문제들의 중복 여부 확인__
- 일단 재귀함수로 표현 후 __작은 문제에서 구한 답이 큰 문제에서 그대로 사용__ 될 수 있으면 == __메모이제이션 적용가능__ 하면 개선하는 방법
- 가능하다면 재귀 함수 이용 탑 다운 방식보다 __보텀업 방식으로 구현__ 하는 것 권장

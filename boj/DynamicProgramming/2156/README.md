# boj 2156: 포도주 시식 by seoyoung
> 문제 주소: https://www.acmicpc.net/problem/2156
> 
> silver 1

## 문제
연속으로 놓여 있는 3잔을 마실 수 없는 상황에서, 주어진 포도주를 가장 많이 마실 수 있는 양을 구하라.
책에 나온 두번째 예제와 비슷한 문제이다.

## 문제 해결 방향
- 규칙을 발견해 점화식을 잘 세우는 것이 중요! 직접 해보고 규칙을 찾아야 하는 듯 하다. 사진 참고
- 3번 연속 포도주를 마실 수 없는 경우의 규칙을 살펴보자.
1. 해당 순서의 포도주를 마시는 경우 (이전 포도주를 마시는 경우 / 안마시는 경우)
2. 해당 순서의 포도주를 마시지 않는 경우

규칙을 발견해 점화식을 잘 세우는 것이 중요! 직접 해보고 규칙을 찾아야 하는 듯 하다.
![boj2156](https://github.com/juyoung810/idecs-algorithm-study/blob/5e66f1088e0cf494f00f0660707b80cd31db8bd1/img/sy_2156.JPG)



해당 표에서 경우의 수를 살펴보면, 3번째에서 w1+w2가 두번째의 슌서까지의 최댓값와 같다.

4번째의 경우의 수를 보면, w2+w3은 3번째에서의 최대값과 같고, w1+w2+w4에서 w1+w2는 두번째 순서까지의 최댓값과 같고, w1+w3+w4에서 w1은 첫번째의 최댓값과 같다.

이 규칙으로 경우의 수를 수식화 하면 dp[4-1], dp[4-3=1]+w[4-1=3]+w[4], dp[4-2=2]+w[4] 이고, 여기서 4를 i로 바꿔주면

- dp[i-1] : 해당 순서의 포도주를 마시지 않는 경우. 직전 순서에서의 최댓값
- dp[i-3]+w[4-1]+w[i] : 해당 순서의 포도주와 이전 포도주를 마시는 경우. 두 포도주의 양과 3개 전 포도주까지의 최댓값
- dp[i-2]+w[i] : 해당 순서의 포도주를 마시고 이전 포도주를 안 마시는 경우. 해당 순서의 포도주의 양과 2개 전 순서까지의 최댓값을 더해준다.

 이 중 가장 큰 값을 넣어주면 된다.

####또 중요한 포인트! 와인 잔의 개수 n에 따라 조건을 넣어줘야 한다. 3잔 이상일 때부터 점화식을 적용 가능하기 때문


## 소스코드
포도주 잔의 개수와 각각의 잔의 포도주의 양을 입력받는다. 최댓값을 입력받을 배열을 생성해 0으로 초기화한다.
```python
n = int(input())
wine = []

for i in range(n):
    wine.append(int(input()))

d = [0] * n
```
와인 잔의 개수에 따른 조건을 적용시켜 준다. 점화식을 그냥 그대로 옮기면 된다. 와인 잔의 개수만큼 최댓값 배열의 값을 채우는 과정을 반복한다.
```python
if n == 1:
    print(wine[0])
elif n == 2:
    print(sum(wine))
else:
    d[0] = wine[0]
    d[1] = d[0] + wine[1]
    d[2] = max(d[1], d[0] + wine[2], wine[1] + wine[2])

    for j in range(3, n):
        d[j] = max(d[j-1], d[j-2] + wine[j], d[j-3] + wine[j-1] + wine[j])

    print(d[n-1])
```

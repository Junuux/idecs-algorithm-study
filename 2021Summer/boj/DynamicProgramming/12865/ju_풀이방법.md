# <span style= "color:red">boj 12865: 평범한 배낭
> 문제 주소: https://www.acmicpc.net/problem/12865
> 
> gold 5


## 문제 해결 방향
- 띄엄띄엄 더해도 되므로 연속적으로 무게를 저장해서 비교할 수 없다.
- 무게가 같을 경우 더 큰 가치를 더하는 경우도 고려한다.
- 무게가 주어진 무게보다 큰 경우를 고려한다.
- 해당 무게의 가치가 다른 것의 합 보다 큰 경우를 고려한다.

- __n+1 개의 k+1 배열을 0으로 초기화한다. -> 즉 아이템이 들어올 때 마다, 해당 아이템의 k+1 개 내의 무게를 비교한다.__
```python
dp = [[0 for _ in range(k+1)] for _ in range(n+1)]
```

### 소스코드
- 해당 아이템 i 행의 무게를 1 부터 K 까지 비교한다.
- 입력한 무게가 j의 무게 보다 큰 경우 , 결국 K보다 커서 담지 못하는 경우, 이전 행의 같은 무게의 value와 같게 한다.
- 입력한 무게가 j 보다 작아 물건을 넣을 수 있는 경우, 
  
   - 이전 행에서 해당 j 무게의 가치 = 이미 j 무게의 가치가 더 큰 경우 
   - 입력한 무게를 더한 가치 = 이전 행의 해당 무게에서 아직 w를 더하지 않은 값의 가치 + 입력한가치
   - 둘 중에 더 큰 값을 해당 아이템이 들어왔을 때, 구한 무게마다의 최댓값으로 설정한다.
    
- dp[n][k]= n번째 아이템이 들어왔을 때, k 무게에 들어갈 수 있는 최대의 가치
    
```python
for i in range(1,n+1):
    w,v = map(int,sys.stdin.readline().split())
    # 무게마다 가격을 비교할 수 있도록 한다.
    for j in range(1,k+1):
        # 주어진 무게보다 입력한 무게가 더 클 경우
        if w > j:
            dp[i][j] = dp[i-1][j]
        # 주어진 무게가 가방 무게 보다 적어서 들어갈 수 있을 때
        else:
            # 해당 무게에서, 해당 물건을 더했을 때랑 안더했을 때 대소를 비교해서 넣는다.
            # 해당 무게에서 물건 담지 않았을 때 -> 해당 무게의 기존 가격
            # 해당 무게에서, 물건 담았을 때 -> 기존에 w를 담지 않았을 때의 가치에서 +v를 한 것을 비교한다.
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-w] + v)
```

### 알게 된 점
- 띄엄띄엄 더해야할 때, 무게를 아이템 수 만큼 뿌리고, 아이템이 들어올 때 마다, 이전 값 현재 값을 비교하면 여러개의 같은 무게를 가진
아이템, 하나가 제일 클 때 등을 신경 쓰지 않아도 된다.
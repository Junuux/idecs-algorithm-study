# boj 2293: 동전 1 by juyoung
> 문제 주소: https://www.acmicpc.net/problem/2293
> 
> silver 1

# 문제 해결 방법
- dp 테이블을 통해 바톰업 방식으로 경우의 수를 구해야한다.
- i - n 까지 동전을 다 만들었을 때, i - n  방법수 + 이미 i를 만들었던 방법 수 를 하면,
이미 i 동전을 만들었던 방법 + 새로운 n 동전으로 i 동전 만들 수 있는 방법을 다 더한 것이다.
  - ex) n = 3, k = 10이라고 하고, 동전은 1,2,5 가 존재한다고 하자.
    1.동전 1 로 만들 수 있는 방법의 수는 모두 1이다.
    2. 4원을 동전 2까지 해서 만들 수 있는 방법의 수는 이미 1로 만든 수 + 2를 만들 수 있는 방법 수 이다.
    (2만들 수 있었던 방법수 + 2원하면 4원이니까..)
       
- 따라서
  1. 주어진 코인의 방법수는 +1
  2. 주어진 코인보다 큰 수는 d[i] = d[i] + d[i-주어진 코인]  이다.
    
```python

n,k = map(int,input().split())
array = []
for _ in range(n):
    array.append(int(input()))

# 처음엔 모두 0
d = [0] * 100001

for i in range(n):
    # 주어진 코인의 방법 수는 자체로 하나의 방법이 되므로 +1
    d[array[i]] = d[array[i]] + 1
    # 주어진 코인 이후 ~ K
    for j in range(array[i] + 1,k+1):
        # ex) j = 7이고, d = 2인데 5를 만드는 방법이 0 이였으면 2를 가지고 만들 수 있는 방법이 없으므로 0이 아닐 떄
        if d[j-array[i]] != 0:
            # 방법 수 = 원래 방법 수 + N-i 까지 다 채웠을 때 방법 수 
            d[j] = d[j] + d[j-array[i]]


print(d[k])
```
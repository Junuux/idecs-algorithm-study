## 문자열 뒤집기
-0과 1로만 이루어진 문자열 s에 있는 모든 숫자를 전부 같게 만들려고 한다. 연속된 하나 이상의 숫자를 잡고 모두 뒤집는다.
문자열이 주어졌을 때, 해야 하는 행동의 최소 횟수를 출력하라.

### 문제 해결 방향
- 하나의 숫자로 바꿔야 하기 때문에, 0만 다 뒤집거나 1만 다 뒤집으면 된다.
  즉 연속되는 숫자를 그룹으로 묶었을 때 그 그룹의 수가 더 적은 걸 뒤집는다.
- 이전의 원소와 달라지는 지점을 찾을 때마다 원소 값을 확인해서 0 또는 1에 추가하고, 둘 중 더 작은 값을 출력한다.


### 소스코드
- 첫 번째 원소를 확인해서 추가해준 후, 두번째 원소부터 이전의 원소와 똑같은지 확인한다.
- 다른 원소인 경우(숫자가 바뀌는 경우), 바뀐 원소가 1이면 1에, 0이면 0에 1을 추가해준다.
```python
s = input()

count_0 = 0
count_1 = 0

if s[0] == '0':
    count_0 += 1
else:
    count_1 += 1

for i in range(1, len(s)):
    if s[i] != s[i-1]:
        if s[i] == '0':
            count_0 += 1
        else:
            count_1 += 1

print(min(count_0, count_1))
```

### 틀렸다고 뜬 코드들

- 아이디어는 동일하다. 이전 원소와 현재 원소를 비교해서 하는 방법.
- 근데 넘 복잡하고 길다. 그리고 변화하는 지점에서 이건 다음 원소를 기준으로 저장하는데 책에서는 이전 원소를 기준으로 한다.
```python
s = input()

zero = 0
one = 0
bf = s[0]
af = s[0]

for i in range(len(s)):
    if i == len(s):
        if s[i] == '0':
            zero += 1
        else:
            one += 1
        break
    af = s[i]
    if bf == af:
        continue
    else:
        if bf == '0':
            zero += 1
        else:
            one += 1
    bf = af

print(min(zero, one))
```
- 이건 내 생각에는 제일 간단한 코드... 예제는 잘 출력되는데 뭐가 문제인지 솔직히 모르겠음 ㅋ
  - 알았다...! 1로 split하면 1 하나만 있을 때는 공백이 출력이 안된다. 그리고 1로 시작할때도 count가 안됨. 완전 잘못된 코드...ㅋㅋ
  - 너무 단순하게 생각해버렸다.  
    
내 생각에는 이랬다...
- 문자열을 입력받은 다음에 1을 기준으로 나눈다.
    - 0001100 을 입력하면 결과가 ['000', '', '00']으로 나온다.
    - 1로 나누면 이렇게 연속된 그룹으로 묶어진 결과가 나온다. 0으로는 다르게 나오더라... 1로 묶어야함
- 때문에 1로 묶인 그룹의 수는 리스트에서 공백의 개수를 세면 되고, 0으로 묶인 그룹의 수는 리스트에서 1 그룹 수를 빼면 된다.
```python
s = input()

s = s.split('1')
one = s.count('')
zero = len(s) - one

print(min(zero, one))
```
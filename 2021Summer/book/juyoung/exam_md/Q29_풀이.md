# <span style="color:red"> Q29: 공유기 설치
> 문제 주소 : www.acmicpc.net/problem/2110
> 
> binarySearch / silver 1


## 문제 설명
-집 N개가 수직선 위에 위치(집 같은 위치에 위치하지 않는다.)
- 집에 공유기 C개 설치
- 한 집에 공유기 하나 설치, 가장 인접한 두 공유기 사이 거리 가능한 크게
- C개의 공유기 N개의 집에 적당히 설치해서, 가장 이넙한 두 공유기 사이의 거리 최대
- 가장 인접한 두 공유기 사이의 최대 거리 출력


## 문제 해결 방향
- 단위 거리가 1일 때 설치할 수 있는 공유기 수는? -> 2일 때? -> 단위거리가 최대 거리일 때 설치할 수 있는 공유기 수는?
- 가장 먼거리 10억이기 때문에, 이진 탐색 통해 탐색의 범위를 줄인다.

## 소스 코드
1. n,c 와 집의 좌표 입력 받는다.
- 이진 탐색하기 위해 입력 받은 집의 좌표를 정렬해야한다.
```python
# n,c 입력 받기
n, c = map(int, input().split())
# 집 좌표 입력 받기 -> 이분 탐색 위해 오름 차순 정렬
homes = []
for _ in range(n):
    homes.append(int(input()))
homes.sort()
```
2. 이진 탐색
- 집의 최소 단위 거리는 1이고, 최대 단위 거리는 (가장 큰 좌표 - 가장 작은 좌표)이다.
- mid 가 단위 거리일 때, 설치할 수 있는 공유기의 수를 count 한다.
- 공유기는 최대 단위 거리로 구하기 위해 반드시 첫번째 좌표에 먼저 공유를 설치해야한다.
- 이전 설치 공유기 + mid 가 현재 좌표보다 작거나 크면, 단위 거리보다 큰 것 이므로 공유기 설치 가능
- 현재 mid일 때 , 공유기 수가 알맞게 설치 되었지만, 단위 거리 더 키웠을 때도 count 성립할 수 있다.

- mid 일 때, 공유기 설치수가 목표보다 작다. -> 더 작은 단위 거리에서 탐색
- mid 일 때, 공유기 설치수가 목표 수보다 크다. -> 더 큰 단위 거리에서 탐색
```python
start = 1  # 최소 단위거리 = 1 (겹치는 집 좌표 없으므로)
end = max(homes) - min(homes)  # 최대 단위 거리
while start <= end:
    mid = (start + end) // 2
    # mid가 단위 거리일 때, 배치할 수 있는 공유기 수 구하기
    count = 1
    install = homes[0]  # 첫번째는 무조건 설치해야 거리가 최대
    for i in range(1, n):
        if homes[i] >= install + mid:  # 단위 거리 충족했으면
            count += 1
            install = homes[i]

    # 와이파이 개수가 C 보다 작으면 더 설치 해야한다. -> 간격을 좁힌다.
    if count < c:
        end = mid - 1
    # 와이파이 개수가 C 보다 크면 덜 설치해야 한다. -> 간격을 넓힌다
    else:
        start = mid + 1
        answer = mid # 간격 넓혀서 더 큰 최대 거리 구할 수 도 있으니까..

```
3. 저장한 answer 변수 출력
```python
print(answer)
```

# 최단 경로 알고리즘 = 가장 빠른 길 찾기

- 여러가지 경우 존재
1. 한 지점에서 다른 특정 지점까지의 최단 경로 구하기
2. 모든 지점에서 모든 지점까지의 최단 경로 모두 구하기

- 최단 경로 문제는 그래프로 표현 -> 간선, 노드로 표현
- 여러가지 알고리즘 존재
1. 다익스트라 최단 경로
2. 플로이드 워셜 알고리즘
3. 벨만 포드 알고리즘

- 그리디 알고리즘과 다이나믹 프로그래밍 알고리즘이 최단 경로 알고리즘에 그대로 적용된다.
-> 그리디 알고리즘 및 다이나믹 프로그래밍 알고리즘의 한 유형이다.
 
---  
## 다익스트라 최단 경로 알고리즘
> 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘

- `음의 간선`(0보다 작은 값) 이 없을 때 정상적으로 동작한다.
- '가장 비용이 적은 노드'를 선택해서 임의의 과정을 반복하기 때문에 그리디 알고리즘으로 분류된다.
- 알고리즘 원리
    1. 출발 노드를 설정한다.
    2. 출발노드에 대해 최단 거리 테이블을 초기화한다.
    3. 방문 하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
    4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
    5. 3,4번 과정을 반복한다.
    
- __`각 노드에 대한 현재까지의 최단 거리` 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다.__
- 매번 현재 처리하는 노드를 기준으로 주변 간선을 확인해서, 더 짧은 경로를 찾으면 '더 짧은 경로도 있었네? 이제부터는 이 경로가 제일 짧은 경로야'라고
판단
  
- '방문하지 않은 노드 중에서 현재 최단 거리가 가장 짧은 노드를 확인' -> 그리디 알고리즘
- __한 단계당 하나의 노드에 대한 최단 거리를 확실하게 찾는다.__ -> 마지막 노드에 대해서는 다른 노드로 가는 경우 확인할 필요 없다. 나머지가 이미 최단 거리가
확정된 상태이기 때문에 더 이상 테이블을 갱신할 수 없기 때문
### 구현
1. 구현하기 쉽지만 느리게 동작하는 코드
2. 구현하기에 까다롭지만 빠르게 동작하는 코드

#### 1. 간단한 다익스트라 알고리즘의 구현 
> O(V^2) , V는 노드의 갯수

- 단계마다 '방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택' 하기 위해 __매 단계마다 1차원 리스트의 모든 원소를 순차탐색__
한다.
- 1차원 리스트 초기화-> 가능한 가장 큰 값으로 `INF = int(1e9)`
```python
import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수, 간선의 개수 입력받기
n,m = map(int,input().split())
# 시작 노드 번호를 입력받기
start = int(input())
# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
graph = [[]for i in range(n+1)]
# 방문한 적이 있는지 체크하는 목적의 리스트 만들기
visited = [False] * (n+1)
# 초단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n+1)

# 모든 간선의 정보 입력받기
for _ in range(m):
    a,b,c = map(int,input().split()) # a -> b 비용 c
    graph[a].append((b,c))

# 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
def get_smallest_node():
    min_value = INF
    visited[start] = True
    index = 0 # 반환 위한 인덱스
    for i in range(1,n+1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    # 시작 노드에 대해서 초기화
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        # start 와 연결된 노드의 비용을 distance로 입력
        distance[j[0]] = j[1]
    # 시작 노드를 제외한 전체 n-1 개의 노드에 대해 반복
    for i in range(n-1):
        # 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
        now = get_smallest_node()
        visited[now] = True
        # 현재 노드와 연결된 다른 노드를 확인
        for j in graph[now]:
            cost = distance[now] + j[1]
            # 현재 노드를 거쳐서 다른 노드로 이동 하는 거리가 더 짧은 경우 갱신
            if cost < distance[j[0]]:
                distance[j[0]] = cost

# 다익스트라 알고리즘 수행
dijkstra(start)
```  
##### 시간 복잡도
- 총 O(V) 에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색해서, 현재 노드와 연결된 노드를 매번 일일이 확인하기 때문에
__ O(V^2)__
  
- 전체 노드 개수 5,000개 이하이면 이 코드 가능, 10,000개 넘어서는 문제면 이 코드로 해결하기 어렵다.

#### 2. 개선된 다익스트라 알고리즘
> O(ElogV), E: 간선 수 V: 노드 수 
- 최단 거리가 가장 짧은 노드를 단순히 선형적으로 찾는 것이 아니라 빠르게 찾을 수 있도록 한다.
- 리스트 대신 __힙(HEAP) 구조__ 사용
- 특정노드까지 최다 거리에 대한 정보를 힙에 담아서 처리하므로 출발 노드로 부터 가장 거리가 짧은 노드를 더욱 빠르게 찾을 수 있다.
- 우선 순위 큐에서 노드 꺼낸 뒤 해당 노드 이미 처리한 적 있다면 무시
 

```python
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9)

# 노드 개수, 간선의 개수 입력받기
n,m = map(int,input().split())
# 시작 노드 번호 입력 받기
start = int(input())

# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트 만들기
graph  = [[] for _ in range(n+1)]
# 최당 경로에 대한 정보 받는 리스트
distance = [INF] * (n+1)

# 모든 간선의 정보를 입력받기
for _ in range(m):
    a,b,c = map(int,input().split()) #a -> b, 비용 c
    graph[a].append((b,c))
    

def dijkstra(start):
    q = []
    # 시작 노드로 가기 위한 최단 경로는 0 으로 설정하여, 큐에 삽입
    heapq.heappush(q,(0,start))
    distance[start] = 0
    while q:  # 큐가 비어있지 않다면
        # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
        dist,now = heapq.heapop(q)
        # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
        if distance[now] < dist:
            continue
        # 현재 노드와 연결된 다른 인접한 노드들을 확인
        for i in graph[now]:
            cost = dist + i[1]
            # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q,(cost,i[0]))

# 다익스트라 알고리즘을 수행
dijkstra(start)
```
##### 시간 복잡도
- O(ElogV)
- 노드를 하나씩 꺼내 검사하는 while 문은 노드의 개수 V 이상의 횟수로는 반복되지 않는다.
- V번 반복될 때 마다 자신과 연결된 간선들을 모두 확인한다.
- '현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들ㅇ르 확인' 하는 총 횟수는 E 만큼 연산 수행될 수 있다.
- 다익스트라 최단 경로 알고리즘은 E개의 원소 우선 순위 큐에 넣었다가 모두 빼는 연산과 유사 -> O(ElogE)
- 중복 간선 제외하면 E는 항상 V^2 보다 작다. -> 시간 복잡도 O(ElogV)

### HEAP
> 우선순위 큐를 구현하기 위해 사용하는 자료구조 중 하나
- __우선 순위가 가장 높은 데이터를 가장 먼저 삭제__
- `PriorityQueue` < `heapq` 사용
- __첫 번째 원소 기준__ 정렬
- 최소 힙: default, 가치 가장 작은 게 먼저 삭제
- 최대 힙: 우선 순위에 해당하는 값에 - 붙여서 정렬, 가치 가장 큰 게 먼저 삭제

  |우선 순위 큐 구현 방식|삽입시간|삭제 시간|
  |---|---|---|
  |리스트| O(1) | O(N)|
  |힙| O(logN) | O(logN)|

---

## 플로이드 워셜 알고리즘
> 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우
- 단계마다 '거쳐 가는 노드'를 기준으로 알고리즘을 수행한다. -> 매번 방문하지 않은 노드 중 최단 거리 갖는 노드 찾을 필요 없다.
- 노드 개수 N개 일 떄 , N 번의 단계 수행하고, 단계 마다 O(N^2)의 연산을 통해 '현재 노드를 거쳐 가는' 모든 경로를 고려한다.
- __시간 복잡도: O(N^3)__
- 플로이드 워셜 알고리즘은 모든 노드에 대해 최단 거리를 구하므로 __2차원 리스트에 최단 거리 정보 저장__ -> 매 단계 O(N^2)의 시간 소요
- 노드 개수 N개 일 때, N 번 만큼의 단계를 반복하며 '점화식에 맞게' 2차원 리스트 개신 -> 다이나믹 프로그래밍
- __각 단계에서는 해당 노드를 거쳐 가는 경우를 고려한다.__
- 현재 확인하고 있는 노드를 제외하고, N-1 개의 노드 중에서 서로 다른 노드 (A,B) 쌍을 선택한다. 이후에 A-> 현재 노드-> B 로 가는 비용을 확인 한 후
더 작을 경우 최단 A,B 사이의 최단 거리를 갱신한다. -> __N-1P2 개의 쌍을 단계마다 반복해서 확인한다.__
  
- __점화식 : Dab = min(Dab,Dak+Dkb)__ :  A에서 B로 가는 최소 비용 VS A에서 K를 거쳐 B로 가는 비용 -> 더 작은 것으로 갱신
- 이차원 배열의 모든 Dii는 0으로 초기화. -> 왼쪽위 오른쪽 아래 대각선은 모두 0

```python
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정
# 노드의 개수 및 간선의 개수를 입력받기
n = int(input())
m = int(input())
# 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
graph = [[INF] * (n+1) for _ in range(n+1)]

#자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
for a in range(1,n+1):
    for b in range(1,n+1):
        if a==b:
            graph[a][b] = 0

# 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
for _ in range(m):
    a,b,c = map(int,input().split())
    graph[a][b] = c

# 점화식에 따라 플로이드 워샬 알고리즘을 수행
for k in range(1,n+1):
    for a in range(1,n+1):
        for b in range(1,n+1):
            graph[a][b] = min(graph[a][b],graph[a][k]+graph[k][b]) ## 자기 자신은 항상 0 이니까 min이 되므로 신경쓰지 않아도 된다.

```
